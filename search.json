[{"title":"Vue 3 启航","url":"/2025/11/15/vue-learning-1/","content":"<h1 id=\"梦开始的地方\"><a href=\"#梦开始的地方\" class=\"headerlink\" title=\"梦开始的地方\"></a>梦开始的地方</h1><p>记得刚接触前端的时候，大家还在用 jQuery 一把梭。那时候的代码充满了 <code>$</code> 符号，回调地狱更是家常便饭，三件套东一块西一块是常态。后来 React 和 Vue 横空出世，带给了我们全新的组件化开发体验。而今天，我正式决定投入 Vue 3 的怀抱。</p>\n<h2 id=\"为什么选择-Vue-3？\"><a href=\"#为什么选择-Vue-3？\" class=\"headerlink\" title=\"为什么选择 Vue 3？\"></a>为什么选择 Vue 3？</h2><p>有人说 React 更灵活，有人说 Angular 更规范。但在我看来，Vue 3 找到了优雅与性能的完美平衡点。</p>\n<ol>\n<li><strong>性能的质变</strong>：Vue 3 重写了响应式系统，利用 ES6 的 Proxy 取代了 <code>Object.defineProperty</code>。这意味着什么？意味着我们再也不用担心数组下标修改监听不到的问题了！而且，初始化的速度快得惊人。</li>\n<li><strong>Composition API</strong>：这绝对是 Vue 3 最大的杀手锏。在 Options API 时代，一个功能的逻辑往往分散在 <code>data</code>、<code>methods</code>、<code>computed</code> 里，维护起来像是在玩“找你妹”。而现在，我们可以像这就写原生 JS 一样，把相关逻辑聚合在一起。这简直是代码组织的神器！</li>\n<li><strong>TypeScript 支持</strong>：Vue 2 对 TS 的支持简直是灾难，而 Vue 3 是用 TS 重写的。这意味着我们在写 Vue 的时候，终于可以享受完整的类型推断了。再见，<code>any</code> scirpt！</li>\n</ol>\n<h2 id=\"我的第一个-Vue-3-Demo\"><a href=\"#我的第一个-Vue-3-Demo\" class=\"headerlink\" title=\"我的第一个 Vue 3 Demo\"></a>我的第一个 Vue 3 Demo</h2><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ref, onMounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">setup</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> count = <span class=\"title function_\">ref</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">increment</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      count.<span class=\"property\">value</span>++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"title function_\">onMounted</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;组件挂载完成！&#x27;</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; count, increment &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看着这简洁的代码，我仿佛看到了光明的未来。没有了 <code>this</code> 的困扰，一切都变得那么直观。</p>\n<p><img src=\"/img/006.png\" alt=\"激动\"></p>\n","categories":["Vue学习之路"],"tags":["Vue","前端","Vue3","学习"]},{"title":"前端性能优化：只要我跑得够快，Bug 就追不上我","url":"/2026/01/15/vue-learning-11/","content":"<h1 id=\"性能优化：无底洞\"><a href=\"#性能优化：无底洞\" class=\"headerlink\" title=\"性能优化：无底洞\"></a>性能优化：无底洞</h1><p>说页面加载太慢，要优化。好，我优化。</p>\n<p>你知道的，一个three.js地图，配上一大堆数据，能加载的快就有鬼了。</p>\n<h2 id=\"漫漫长路\"><a href=\"#漫漫长路\" class=\"headerlink\" title=\"漫漫长路\"></a>漫漫长路</h2><ol>\n<li><strong>代码分割（Code Splitting）</strong>：路由懒加载，组件异步加载。好，首屏快了一点。</li>\n<li><strong>图片压缩</strong>：上了 WebP，上了 CDN。</li>\n<li><strong>减少重排重绘</strong>：小心翼翼地操作 DOM。</li>\n<li><strong>Tree Shaking</strong>：检查打包产物，去掉了无用的 lodash 引入。</li>\n</ol>\n<h2 id=\"结果呢？\"><a href=\"#结果呢？\" class=\"headerlink\" title=\"结果呢？\"></a>结果呢？</h2><p>乐了，更卡了。</p>\n<h2 id=\"心态崩了\"><a href=\"#心态崩了\" class=\"headerlink\" title=\"心态崩了\"></a>心态崩了</h2><p>毁灭吧，赶紧的。累了。</p>\n<h2 id=\"为什么这么难？\"><a href=\"#为什么这么难？\" class=\"headerlink\" title=\"为什么这么难？\"></a>为什么这么难？</h2><p>前端不就是画画界面调调接口吗？为什么要搞这么复杂？Webpack 还没整明白，Vite 又来了；Vue 3 又变了。学不动了，真的学不动了。</p>\n<p><img src=\"/img/006.png\" alt=\"性能\"></p>\n","categories":["Vue学习之路"],"tags":["Vue","前端","性能","技术"]},{"title":"Vite：快！太快了！由于速度太快我跟不上了","url":"/2026/01/10/vue-learning-10/","content":"<h1 id=\"Vite：这也太快了吧…-还有报错\"><a href=\"#Vite：这也太快了吧…-还有报错\" class=\"headerlink\" title=\"Vite：这也太快了吧… 还有报错\"></a>Vite：这也太快了吧… 还有报错</h1><p>Vite 宣称是下一代前端构建工具。启动确实快，毫秒级。</p>\n<h2 id=\"开发爽，打包火葬场\"><a href=\"#开发爽，打包火葬场\" class=\"headerlink\" title=\"开发爽，打包火葬场\"></a>开发爽，打包火葬场</h2><p>开发环境用的是 ES Modules，不需要打包，所以快。但是生产环境还是用的 Rollup 打包。<br>这就导致了一个极其恶心的问题：<strong>开发环境跑得好好的，一打包上线就报错！</strong></p>\n<p>有些依赖包不是 ESM 格式，Vite 开发时会预构建解决，但在生产打包时，Rollup 的配置如果没有把 commonjs 转好，直接崩。我曾经为了一个老旧的加密库，折腾了整整两天 Vite 配置。<code>optimizeDeps</code>、<code>rollupOptions</code>、<code>commonjsOptions</code>… 每一个配置项都像是在嘲笑我的无知。</p>\n<h2 id=\"心态崩了\"><a href=\"#心态崩了\" class=\"headerlink\" title=\"心态崩了\"></a>心态崩了</h2><p>毁灭吧，赶紧的。累了。</p>\n<p>我们先来聊聊 Vite 的核心概念。在官方文档中，这一部分被描述得非常晦涩难懂。我花了整整三天时间查阅源码，翻遍了 GitHub 上的 Issues，才勉强理解了其中的奥妙。简单来说，它就像是一个黑盒子，你输入 A，它输出 B，但中间发生了什么，只有上帝和尤雨溪知道。</p>\n<p>代码示例方面，我尝试写了一个 Demo，结果控制台满屏飘红。这哪里是写代码，简直是在扫雷。每一个变量的定义都充满了不确定性，每一个函数的调用都像是在赌博。</p>\n<p><img src=\"/img/029.jpg\" alt=\"Vite\"></p>\n","categories":["Vue学习之路"],"tags":["Vue","前端","Vite","工具"]},{"title":"深坑记录：响应式丢失的那一夜","url":"/2026/01/21/vue-learning-12/","content":"<h1 id=\"那个让我通宵的-Bug\"><a href=\"#那个让我通宵的-Bug\" class=\"headerlink\" title=\"那个让我通宵的 Bug\"></a>那个让我通宵的 Bug</h1><p>那是周五的晚上，本该是快乐的周末开始。但是测试报了一个致命 Bug：用户点完保存，列表数据没有更新，必须刷新页面才行。</p>\n<h2 id=\"排查过程\"><a href=\"#排查过程\" class=\"headerlink\" title=\"排查过程\"></a>排查过程</h2><ol>\n<li><strong>查接口</strong>：后端接口返回的数据是新的，没问题。</li>\n<li><strong>查 Vue DevTools</strong>：发现 store 里的数据确实可以更新，但是组件里的数据没变。</li>\n<li><strong>定位代码</strong>：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// store.js</span></span><br><span class=\"line\"><span class=\"attr\">state</span>: <span class=\"function\">() =&gt;</span> (&#123; <span class=\"attr\">list</span>: [] &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// component.vue</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; list &#125; = userStore</span><br></pre></td></tr></table></figure>\n\n<p>就是这行解构！在 Options API 里习惯了 <code>this.list</code>，在 Setup 里直接解构 store，导致 <code>list</code> 变成了一个普通的数组，失去了响应性连接。</p>\n<h2 id=\"心态崩了\"><a href=\"#心态崩了\" class=\"headerlink\" title=\"心态崩了\"></a>心态崩了</h2><p>毁灭吧，赶紧的。累了。</p>\n<p>我们先来聊聊 Vue 响应式的核心概念。在官方文档中，这一部分被描述得非常晦涩难懂。我花了整整三天时间查阅源码，翻遍了 GitHub 上的 Issues，才勉强理解了其中的奥妙。简单来说，它就像是一个黑盒子，你输入 A，它输出 B，但中间发生了什么，只有上帝和尤雨溪知道。</p>\n<h2 id=\"为什么这么难？\"><a href=\"#为什么这么难？\" class=\"headerlink\" title=\"为什么这么难？\"></a>为什么这么难？</h2><p>前端不就是画画界面调调接口吗？为什么要搞这么复杂？Webpack 还没整明白，Vite 又来了；Vue 2 刚熟练，Vue 3 又变了。学不动了，真的学不动了。</p>\n<p><img src=\"/img/008.png\" alt=\"踩坑\"></p>\n","categories":["Vue学习之路"],"tags":["Vue","前端","Vue3","踩坑"]},{"title":"我累了：试图理解源码，结果被源码理解了","url":"/2026/01/23/vue-learning-14/","content":"<h1 id=\"源码阅读：从入门到放弃\"><a href=\"#源码阅读：从入门到放弃\" class=\"headerlink\" title=\"源码阅读：从入门到放弃\"></a>源码阅读：从入门到放弃</h1><p>为了提升自己，我决定阅读 Vue 3 源码。打开 <code>core</code> 仓库，看到那几万行 TS 代码，我陷入了沉思。</p>\n<h2 id=\"晦涩的渲染器\"><a href=\"#晦涩的渲染器\" class=\"headerlink\" title=\"晦涩的渲染器\"></a>晦涩的渲染器</h2><p><code>renderer.ts</code>，几千行的 switch case，各种位运算标记（PatchFlags）。我看了一行，脑子就过载了。这就是大神的思维世界吗？</p>\n<p>我意识到，我可能这辈子都达不到这个水平了。我只是一个 API Consumer，一个熟练的搬砖工。</p>\n<h2 id=\"转折点\"><a href=\"#转折点\" class=\"headerlink\" title=\"转折点\"></a>转折点</h2><p>就在我绝望的时候，我接触到了现在的 AI 编程工具。</p>\n<h2 id=\"AI-才是未来\"><a href=\"#AI-才是未来\" class=\"headerlink\" title=\"AI 才是未来\"></a>AI 才是未来</h2><p>不装了，我摊牌了。手写代码是上个世纪的事情了。</p>\n<h2 id=\"AI-降维打击\"><a href=\"#AI-降维打击\" class=\"headerlink\" title=\"AI 降维打击\"></a>AI 降维打击</h2><p>今天我试了一下 Vibe Code，只需一句话，它就生成了我折腾了三天都没写出来的功能。那一刻，我释然了。我为什么要跟机器比速度？我为什么要跟编译器较劲？</p>\n<p>从今天起，我不再是前端切图仔，我是 AI Prompt 工程师。Vue 3？真不熟。Pinia？没听过。我只知道 “Generate a login page with Vue 3 and Tailwind”。</p>\n<p>真香！</p>\n<p><img src=\"/img/040.jpg\" alt=\"源码\"></p>\n","categories":["Vue学习之路"],"tags":["Vue","前端","源码","放弃"]},{"title":"彻底放弃：拥抱 Vibe Code，AI 才是亲爹","url":"/2026/01/24/vue-learning-15/","content":"<h1 id=\"最终章：拥抱未来\"><a href=\"#最终章：拥抱未来\" class=\"headerlink\" title=\"最终章：拥抱未来\"></a>最终章：拥抱未来</h1><p>这是我《Vue 学习之路》系列的最后一篇文章。因为，这路我不走了。</p>\n<h2 id=\"为什么放弃？\"><a href=\"#为什么放弃？\" class=\"headerlink\" title=\"为什么放弃？\"></a>为什么放弃？</h2><ol>\n<li><strong>效率差距</strong>：我写个增删改查页面，要 4 小时，调 CSS 还要 1 小时。AI 写，只要 30 秒。</li>\n<li><strong>知识焦虑</strong>：前端技术栈爆炸，学不完。但 AI 已经学完了所有文档。</li>\n<li><strong>幸福感</strong>：写代码是为了创造产品，不是为了修 Bug。</li>\n</ol>\n<h2 id=\"Vibe-Code-体验\"><a href=\"#Vibe-Code-体验\" class=\"headerlink\" title=\"Vibe Code 体验\"></a>Vibe Code 体验</h2><p>打开 Vibe Code，输入：“做一个博客首页，要有毛玻璃效果，基于 Hexo Butterfly 主题风格”。<br>然后，啪！代码出来了。没有语法错误，没有类型报错。</p>\n<p>那一刻，我感觉自己之前的努力就像个笑话。</p>\n<h2 id=\"拥抱变化\"><a href=\"#拥抱变化\" class=\"headerlink\" title=\"拥抱变化\"></a>拥抱变化</h2><p>从今天起，我不再是前端切图仔，我是 AI Prompt 工程师。Vue 3？真不熟。Pinia？没听过。我只知道 “Generate a login page with Vue 3 and Tailwind”。</p>\n<p>在这个快速发展的前端时代，技术的更新迭代速度简直让人窒息。每一次框架的更新，不仅带来了新的特性，也带来了新的焦虑。作为一名追求极致体验的开发者，我深知持续学习的重要性。但是… 真的需要学这么多吗？</p>\n<p>再见了，所有的未定义变量，再见了所有的代码不规范，<code>node_modules</code>。你好，DeepSeek。</p>\n<p>真香！</p>\n<p><img src=\"/img/site_bg_v2.jpg\" alt=\"真香\"></p>\n","categories":["Vue学习之路"],"tags":["Vue","前端","AI","Vibe Code"]},{"title":"逐渐暴躁：为什么前端框架更新这么快？！","url":"/2026/01/22/vue-learning-13/","content":"<h1 id=\"永远学不完\"><a href=\"#永远学不完\" class=\"headerlink\" title=\"永远学不完\"></a>永远学不完</h1><p>今天看到尤雨溪又发了新推特，Vue 3.5 即将发布，又有一堆新特性。Vapor Mode？无虚拟 DOM？</p>\n<p>求求了，别更新了。我 Vue 3.0 的文档还没背熟呢。</p>\n<h2 id=\"疲惫感\"><a href=\"#疲惫感\" class=\"headerlink\" title=\"疲惫感\"></a>疲惫感</h2><p>每次打开 GitHub Trending，都是一堆新轮子。React Server Components, SolidJS, Svelte, Qwik… 每一个都号称颠覆前端。我累了，真的累了。</p>\n<p>作为一名追求极致体验的开发者，我深知持续学习的重要性。但是… 真的需要学这么多吗？</p>\n<h2 id=\"AI-才是未来\"><a href=\"#AI-才是未来\" class=\"headerlink\" title=\"AI 才是未来\"></a>AI 才是未来</h2><p>不装了，我摊牌了。手写代码是上个世纪的事情了。今天我试了一下 Vibe Code，只需一句话，它就生成了我折腾了三天都没写出来的功能。那一刻，我释然了。我为什么要跟机器比速度？我为什么要跟编译器较劲？</p>\n<h2 id=\"拥抱变化\"><a href=\"#拥抱变化\" class=\"headerlink\" title=\"拥抱变化\"></a>拥抱变化</h2><p>回想起刚开始接触 Vue 的时候，那时候的快乐是纯粹的。写一个 <code>&#123;&#123; message &#125;&#125;</code> 就能看到页面变化，那种成就感无与伦比。而现在，我们要处理复杂的依赖关系、难以捉摸的类型定义、层出不穷的构建工具配置。难道这就是成长的代价吗？</p>\n<p>真香！</p>\n<p><img src=\"/img/016.jpg\" alt=\"吐槽\"></p>\n","categories":["Vue学习之路"],"tags":["Vue","前端","吐槽","心情"]},{"title":"Ref vs Reactive：响应式的哲学思考 (头秃篇)","url":"/2025/11/30/vue-learning-2/","content":"<h1 id=\"响应式的哲学\"><a href=\"#响应式的哲学\" class=\"headerlink\" title=\"响应式的哲学\"></a>响应式的哲学</h1><p>在深入学习 Vue 3 的过程中，不管是新手还是老鸟，都会遇到一个经典问题：<code>ref</code> 和 <code>reactive</code> 到底用哪个？</p>\n<h2 id=\"官方的定义\"><a href=\"#官方的定义\" class=\"headerlink\" title=\"官方的定义\"></a>官方的定义</h2><ul>\n<li><code>ref</code>：接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象仅有一个 <code>.value</code> property，指向该内部值。</li>\n<li><code>reactive</code>：返回对象的响应式副本。</li>\n</ul>\n<p>看起来很简单，对吧？<code>ref</code> 处理基本类型，<code>reactive</code> 处理对象。但是在实际开发中，情况远比这复杂。</p>\n<h2 id=\"踩坑实录\"><a href=\"#踩坑实录\" class=\"headerlink\" title=\"踩坑实录\"></a>踩坑实录</h2><p>我曾经试图用 <code>reactive</code> 去定义一个数组，结果发现直接重新赋值会丢失响应性！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list = <span class=\"title function_\">reactive</span>([])</span><br><span class=\"line\"><span class=\"comment\">// ... 异步获取数据后</span></span><br><span class=\"line\">list = newData <span class=\"comment\">// ❌ 响应性丢失！界面不更新！</span></span><br></pre></td></tr></table></figure>\n\n<p>为什么？因为 <code>reactive</code> 返回的是一个 Proxy 对象，直接赋值 <code>list = newData</code> 只是修改了变量 <code>list</code> 的引用，并没有修改原来的 Proxy 对象。</p>\n<p>正确做法是用 <code>ref</code>，或者用 <code>list.push(...newData)</code>。但是 <code>ref</code> 每次都要写 <code>.value</code>，真的好烦啊！在模板里倒是会自动解包，但在 JS 逻辑里，少写一个 <code>.value</code> 就能让你调试半天。</p>\n<h2 id=\"深入思考\"><a href=\"#深入思考\" class=\"headerlink\" title=\"深入思考\"></a>深入思考</h2><p><code>ref</code> 更像是“指针”，明确地告诉我们这里有一个需要被追踪的值；而 <code>reactive</code> 则更贴近原生对象的直觉。</p>\n<p>简单来说，它就像是一个黑盒子，你输入 A，它输出 B，但中间发生了什么，或者是有没有响应到，你只能看输出和输入的情况。</p>\n<p>代码示例方面，我尝试写了一个 Demo，结果控制台满屏飘红。这哪里是写代码，简直是在扫雷。每一个变量的定义都充满了不确定性，每一个函数的调用都像是在赌博。</p>\n<p>也许，与其纠结用哪个，不如统一用 <code>ref</code> 一把梭？毕竟，显示地使用 <code>.value</code> 虽然繁琐，但至少心安。</p>\n<p><img src=\"/img/008.png\" alt=\"思考\"></p>\n","categories":["Vue学习之路"],"tags":["Vue","前端","Vue3","技术"]},{"title":"生命周期钩子：生老病死，Vue 组件的一生","url":"/2025/12/14/vue-learning-4/","content":"<h1 id=\"组件的一生\"><a href=\"#组件的一生\" class=\"headerlink\" title=\"组件的一生\"></a>组件的一生</h1><p>万物皆有灵，Vue 组件也不例外。它们从被创建（Creation），到挂载（Mounting），到更新（Updating），最后销毁（Unmounting），走完了一生。而我们开发者，就是那个掌握生杀大权的神。</p>\n<h2 id=\"Vue-3-的变化\"><a href=\"#Vue-3-的变化\" class=\"headerlink\" title=\"Vue 3 的变化\"></a>Vue 3 的变化</h2><p>在 Vue 2 中，我们熟悉的是 <code>created</code>, <code>mounted</code>, <code>destroyed</code>。在 Vue 3 的 Composition API 中，这些变成了 <code>onMounted</code>, <code>onUnmounted</code> 等等。</p>\n<p>最让我困惑的是 <code>setup()</code>。它在 <code>beforeCreate</code> 和 <code>created</code> 之前执行。这意味着在 <code>setup</code> 里面，我们不需要写这一类的钩子了，直接写逻辑就行。</p>\n<h2 id=\"实际应用中的坑\"><a href=\"#实际应用中的坑\" class=\"headerlink\" title=\"实际应用中的坑\"></a>实际应用中的坑</h2><p>我曾经遇到过一个 Bug，在 <code>onMounted</code> 里面去获取 DOM 元素的高宽。理论上这时候 DOM 已经渲染好了，对吧？</p>\n<p>错！如果你的组件里面有 <code>v-if</code> 或者异步组件，<code>onMounted</code> 触发的时候，子组件可能还没渲染完！这时候拿到的高度是 0。解决办法是用 <code>nextTick</code>，或者检查你的组件结构。</p>\n<h2 id=\"为什么会这样？\"><a href=\"#为什么会这样？\" class=\"headerlink\" title=\"为什么会这样？\"></a>为什么会这样？</h2><p>回想起刚开始接触 Vue 的时候，那时候的快乐是纯粹的。写一个 <code>&#123;&#123; message &#125;&#125;</code> 就能看到页面变化，那种成就感无与伦比。而现在，我们要处理复杂的依赖关系、难以捉摸的类型定义、层出不穷的构建工具配置。难道这就是成长的代价吗？</p>\n<p>我们先来聊聊 Vue 生命周期的核心概念。在官方文档中，这一部分被描述得非常晦涩难懂。我花了整整三天时间查阅源码，翻遍了 GitHub 上的 Issues，才勉强理解了其中的奥妙。简单来说，它就像是一个黑盒子，你输入 A，它输出 B，但中间发生了什么，只有上帝和尤雨溪知道。</p>\n<p>代码示例方面，我尝试写了一个 Demo，结果控制台满屏飘红。这哪里是写代码，简直是在扫雷。每一个变量的定义都充满了不确定性，每一个函数的调用都像是在赌博。</p>\n<p><img src=\"/img/040.jpg\" alt=\"生老病死\"></p>\n","categories":["Vue学习之路"],"tags":["Vue","前端","Vue3","技术"]},{"title":"样式设计：CSS 也就是随便写写... (并没有)","url":"/2025/12/25/vue-learning-5/","content":"<h1 id=\"CSS-的痛与乐\"><a href=\"#CSS-的痛与乐\" class=\"headerlink\" title=\"CSS 的痛与乐\"></a>CSS 的痛与乐</h1><p>作为一个前端，最怕的不是写 JS 逻辑，而是调 CSS 样式。居中？对齐？适配？每一个词都能让猛男落泪。</p>\n<h2 id=\"Vue-中的-Scoped-CSS\"><a href=\"#Vue-中的-Scoped-CSS\" class=\"headerlink\" title=\"Vue 中的 Scoped CSS\"></a>Vue 中的 Scoped CSS</h2><p>Vue 提供了 <code>&lt;style scoped&gt;</code>，这简直是防止样式污染的神器。它通过给元素添加唯一的 data-v-xxx 属性，确保你的样式只在这个组件内生效。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.example</span><span class=\"selector-attr\">[data-v-f3f3eg9]</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是！当你试图修改子组件的样式时（比如修改 Element Plus 的组件样式），<code>scoped</code> 就变成了拦路虎。这时候你就得用深度选择器 <code>:deep()</code>。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parent</span> :<span class=\"built_in\">deep</span>(.child) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* 这样才能穿透过去 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之前不知道这个，我傻傻地去写全局样式，结果污染了整个项目，被组长骂了一顿。</p>\n<h2 id=\"动态样式\"><a href=\"#动态样式\" class=\"headerlink\" title=\"动态样式\"></a>动态样式</h2><p>Vue 3 允许我们在 CSS 中绑定 JS 变量：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.text</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"built_in\">v-bind</span>(color)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>太酷了！这才是现代化开发嘛！</p>\n<p>样式设计看似简单，实则深不可测。Flexbox, Grid, CSS Variables, Tailwind… 学不完，根本学不完。</p>\n<p><img src=\"/img/047.png\" alt=\"CSS\"></p>\n","categories":["Vue学习之路"],"tags":["Vue","前端","CSS","设计"]},{"title":"路由守卫：你是谁？你去哪？有通行证吗？","url":"/2025/12/05/vue-learning-3/","content":"<h1 id=\"前端的保安：Vue-Router\"><a href=\"#前端的保安：Vue-Router\" class=\"headerlink\" title=\"前端的保安：Vue Router\"></a>前端的保安：Vue Router</h1><p>做单页应用（SPA），路由管理是绕不开的一环。而“路由守卫”（Navigation Guards）则是其中最精彩（也最容易出 Bug）的部分。</p>\n<h2 id=\"全局前置守卫：beforeEach\"><a href=\"#全局前置守卫：beforeEach\" class=\"headerlink\" title=\"全局前置守卫：beforeEach\"></a>全局前置守卫：beforeEach</h2><p>这就好比小区门口的保安大爷，不管你是谁，进门先查证。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">router.<span class=\"title function_\">beforeEach</span>(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (to.<span class=\"property\">name</span> !== <span class=\"string\">&#x27;Login&#x27;</span> &amp;&amp; !isAuthenticated) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">next</span>(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Login&#x27;</span> &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">next</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>看起来逻辑天衣无缝？只要没登录，就踢回登录页。但是！如果你的逻辑写得稍微有一点漏洞，就会陷入<strong>无限循环</strong>。</p>\n<p>比如，你忘记判断 <code>to.name !== &#39;Login&#39;</code>，那么用户被重定向到 Login 页，再次触发 beforeEach，再次重定向… 浏览器直接卡死，你也懵逼了。</p>\n<h2 id=\"组件内的守卫\"><a href=\"#组件内的守卫\" class=\"headerlink\" title=\"组件内的守卫\"></a>组件内的守卫</h2><p><code>beforeRouteEnter</code>、<code>beforeRouteUpdate</code>、<code>beforeRouteLeave</code>。这些钩子函数让我们可以精确控制组件级的路由行为。</p>\n<ul>\n<li><strong>beforeRouteEnter</strong>：在渲染该组件的对应路由被 confirm 前调用。注意！此时组件实例还没被创建，所以你不能用 <code>this</code>！这又是 Vue 新手的一大坑。</li>\n<li><strong>beforeRouteLeave</strong>：通常用来禁止用户在未保存修改前突然离开。</li>\n</ul>\n<h2 id=\"遇到的困难与思考\"><a href=\"#遇到的困难与思考\" class=\"headerlink\" title=\"遇到的困难与思考\"></a>遇到的困难与思考</h2><p>对于路由守卫，社区里有很多争论。有人说它是未来，有人说它是过度设计。因为实际上后端配置JWT的情况下，并不需要这玩意。我个人认为，你还是要遇到回传需求的，这玩意总是有用的，而且并不是所有的服务都有完整后端。</p>\n<p><img src=\"/img/016.jpg\" alt=\"保安\"></p>\n","categories":["Vue学习之路"],"tags":["Vue","前端","学习","Vue Router"]},{"title":"Pinia：Vuex 的继任者，好吃又好用","url":"/2025/12/30/vue-learning-6/","content":"<h1 id=\"菠萝（Pinia）真好吃\"><a href=\"#菠萝（Pinia）真好吃\" class=\"headerlink\" title=\"菠萝（Pinia）真好吃\"></a>菠萝（Pinia）真好吃</h1><p>Vuex 复杂的 mutation, action, getter 曾让人头大。Pinia 的出现，简直是清流。</p>\n<h2 id=\"为什么是-Pinia？\"><a href=\"#为什么是-Pinia？\" class=\"headerlink\" title=\"为什么是 Pinia？\"></a>为什么是 Pinia？</h2><ol>\n<li><strong>没有 Mutation</strong>：终于不用为了改个状态写那繁琐的模板代码了，直接在 Action 里改，或者直接改！</li>\n<li><strong>TypeScript 友好</strong>：完美的类型推断，不用像 Vuex 那样写一堆泛型接口。</li>\n<li><strong>极简 API</strong>：<code>defineStore</code> 一把梭。</li>\n</ol>\n<h2 id=\"逐渐掉光的头发\"><a href=\"#逐渐掉光的头发\" class=\"headerlink\" title=\"逐渐掉光的头发\"></a>逐渐掉光的头发</h2><p>随着学习的深入，我发现事情并不像我想象的那么简单。Pinia 这个知识点，简直是我的噩梦。</p>\n<p>文档里写得轻描淡写，实际用起来坑巨多。比如，我在 store 里解构 state，结果响应性丢了！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"title function_\">useUserStore</span>()</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; name &#125; = store <span class=\"comment\">// ❌ 响应性丢失</span></span><br></pre></td></tr></table></figure>\n\n<p>必须用 <code>storeToRefs(store)</code>。这种细节，一旦不知道，就是一下午的调试时间。</p>\n<h2 id=\"令人头秃的细节\"><a href=\"#令人头秃的细节\" class=\"headerlink\" title=\"令人头秃的细节\"></a>令人头秃的细节</h2><p>在这个快速发展的前端时代，技术的更新迭代速度简直让人窒息。每一次框架的更新，不仅带来了新的特性，也带来了新的焦虑。作为一名追求极致体验的开发者，我深知持续学习的重要性。但是，Pinia 的某些行为真的很迷。</p>\n<p>比如，它在服务端渲染（SSR）下的 hydration 问题，经常导致客户端和服务端数据不一致，你以为数据传过去了，结果是如传。我花了整整三天时间查阅源码，翻遍了 GitHub 上的 Issues，才勉强理解了其中的奥妙。简单来说，它就像是一个黑盒子，你输入 A，它输出 B，但中间发生了什么，只有上帝和尤雨溪知道。</p>\n<p><img src=\"/img/049.png\" alt=\"Pinia\"></p>\n","categories":["Vue学习之路"],"tags":["Vue","前端","Pinia","状态管理"]},{"title":"组件通信：Props 传值传到手抽筋","url":"/2025/12/31/vue-learning-7/","content":"<h1 id=\"Props-Emit-Provide-Inject…\"><a href=\"#Props-Emit-Provide-Inject…\" class=\"headerlink\" title=\"Props, Emit, Provide, Inject…\"></a>Props, Emit, Provide, Inject…</h1><p>Vue 的组件通信方式多达十几种。父子通信用 Props&#x2F;Emit，跨层级用 Provide&#x2F;Inject，兄弟组件用 EventBus（Vue 3 移除了，得自己手写或用mitt），全局状态用 Pinia。</p>\n<h2 id=\"传值的痛苦\"><a href=\"#传值的痛苦\" class=\"headerlink\" title=\"传值的痛苦\"></a>传值的痛苦</h2><p>当你有 5 层组件嵌套，最外层的组件想传个 ID 给最里面的组件。<br>Props Drilling（属性透传）简直是灾难。</p>\n<p>Parent -&gt; Child -&gt; GrandChild -&gt; GreatGrandChild -&gt; Target</p>\n<p>每一层都要声明 Props，写得我想吐。虽说可以用 <code>provide/inject</code>，但不仅失去了类型推断的便利（TS 还要额外定义 InjectionKey），而且数据流变得难以追踪。</p>\n<p><img src=\"/img/078.png\" alt=\"通信\"></p>\n","categories":["Vue学习之路"],"tags":["Vue","前端","Vue3","组件"]},{"title":"Composition API：逻辑复用的快乐与痛苦","url":"/2026/01/05/vue-learning-8/","content":"<h1 id=\"组合式-API：双刃剑\"><a href=\"#组合式-API：双刃剑\" class=\"headerlink\" title=\"组合式 API：双刃剑\"></a>组合式 API：双刃剑</h1><p>Composition API 是 Vue 3 的灵魂。它允许我们将逻辑通过 Hooks（Composables）的方式进行提取和复用。</p>\n<h2 id=\"理想很丰满\"><a href=\"#理想很丰满\" class=\"headerlink\" title=\"理想很丰满\"></a>理想很丰满</h2><p>我想象中的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; user &#125; = <span class=\"title function_\">useUser</span>()</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; articles &#125; = <span class=\"title function_\">useArticles</span>()</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; loading &#125; = <span class=\"title function_\">useLoading</span>()</span><br></pre></td></tr></table></figure>\n\n<p>清爽、干净、模块化。</p>\n<h2 id=\"现实很骨感\"><a href=\"#现实很骨感\" class=\"headerlink\" title=\"现实很骨感\"></a>现实很骨感</h2><p>实际写出来的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; user, <span class=\"attr\">loading</span>: userLoading, <span class=\"attr\">error</span>: userError &#125; = <span class=\"title function_\">useUser</span>()</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; articles, <span class=\"attr\">loading</span>: articleLoading, <span class=\"attr\">error</span>: articleError &#125; = <span class=\"title function_\">useArticles</span>()</span><br><span class=\"line\"><span class=\"comment\">// 命名冲突！到处重命名！</span></span><br></pre></td></tr></table></figure>\n\n<p>而且，如果你把所有逻辑都堆在 <code>setup</code> 里，不加以拆分，它就会变成一个巨大的面条代码（Spaghetti Code），比 Options API 还要难以维护。因为 Options API 至少强制你分开了 data 和 methods。严格来说实际上只要你不在乎史山代码，你完全可以不在乎getter和setter，全放在utils里面，所有的state变量都塞在一个const里面。</p>\n<h2 id=\"令人头秃的细节\"><a href=\"#令人头秃的细节\" class=\"headerlink\" title=\"令人头秃的细节\"></a>令人头秃的细节</h2><p>文档里写得轻描淡写，实际用起来坑巨多。比如那个 Hook 的执行时机，如果在 Hook 里面用了 <code>onMounted</code>，它到底是在父组件挂载前还是后？如果 Hook 里有异步操作呢？我之前是写C++这种顺序执行语言的，被这玩意狠狠的摆了一道，同一个函数内所有的调用是同步执行的，除非你用promise进行强行顺序化。</p>\n<p><img src=\"/img/092.jpg\" alt=\"API\"></p>\n","categories":["Vue学习之路"],"tags":["Vue","前端","Vue3","API"]},{"title":"TypeScript：给代码穿上防弹衣 (虽然很重)","url":"/2026/01/07/vue-learning-9/","content":"<h1 id=\"TypeScript：心态崩了\"><a href=\"#TypeScript：心态崩了\" class=\"headerlink\" title=\"TypeScript：心态崩了\"></a>TypeScript：心态崩了</h1><p>毁灭吧，赶紧的。累了。</p>\n<h2 id=\"无尽的报错\"><a href=\"#无尽的报错\" class=\"headerlink\" title=\"无尽的报错\"></a>无尽的报错</h2><p>TypeScript 说是给代码穿上防弹衣，防止低级错误。但实际上，它更像是给我的手戴上了镣铐。</p>\n<p><code>Type &#39;string | null&#39; is not assignable to type &#39;string&#39;.</code><br><code>Property &#39;xyz&#39; does not exist on type &#39;ABC&#39;.</code></p>\n<p>我知道！我知道它是 null！我加了判断了！但 TS 就是不信！非要我写 <code>as string</code> 或者 <code>!</code>。</p>\n<p>尤其是在 Vue 组件的 Props 定义里，结合 <code>defineProps</code> 和泛型，写起来那叫一个酸爽。为了解决一个类型报错，我可能要写几十行的 interface 定义。这到底是写业务逻辑，还是在做类型体操？</p>\n<h2 id=\"为什么这么难？\"><a href=\"#为什么这么难？\" class=\"headerlink\" title=\"为什么这么难？\"></a>为什么这么难？</h2><p>${title} 让我彻底破防了。我在 Pinia 里配了半天状态，结果组件里死活拿不到。控制台的黄色警告和红色错误交织在一起，像是在嘲笑我的无能。</p>\n<p>在这个快速发展的前端时代，技术的更新迭代速度简直让人窒息。每一次框架的更新，不仅带来了新的特性，也带来了新的焦虑。作为一名追求极致体验的开发者，我深知持续学习的重要性。但是… 真的需要学这么多吗？</p>\n<p>前端不就是画画界面调调接口吗？为什么要搞这么复杂？Webpack 还没整明白，Vite 又来了；Vue 3 又变了。学不动了，真的学不动了。</p>\n<p><img src=\"/img/site_bg_v2.jpg\" alt=\"TS\"></p>\n","categories":["Vue学习之路"],"tags":["Vue","前端","技术","TypeScript"]}]